---
slug: "save-ggplot2-targets"
title: How to Save ggplot2 plots in a targets Workflow?
author:
  - Matthias Greni√©
# Set the date below to the publication date of your post
date: 2020-03-10
# Minimal tags for a post about a community-contributed package 
# that has passed software peer review are listed below
# Consult the Technical Guidelines for information on choosing tags
tags:
  - targets
  - ggplot2
  - workflow
  - tech notes
# The summary below will be used by e.g. Twitter cards
description: "A very short summary of your post (~ 100 characters)"
# If you have no preferred image for Twitter cards,
# delete the twitterImg and twitterAlt lines below 
# - Replace "blog" with "technotes" as needed
# - Note no "/" symbol before "blog" here
# - Note "/" between year/month/day
twitterImg: blog/2019/06/04/post-template/name-of-image.png
twitterAlt: "Alternative description of the image"
# the text below is for populating the "share on Twitter" button
# if deleted, the title of the post will be used
tweet: "A post about blabla by @username!"
---

```{r setup, include=FALSE}
# Options to have images saved in the post folder
# And to disable symbols before output
knitr::opts_chunk$set(fig.path = "", comment = "")

# knitr hook to make images output use Hugo options
knitr::knit_hooks$set(
  plot = function(x, options) {
    hugoopts <- options$hugoopts
    paste0(
      "{{<figure src=",
      '"', x, '" ',
      if (!is.null(hugoopts)) {
        glue::glue_collapse(
          glue::glue('{names(hugoopts)}="{hugoopts}"'),
          sep = " "
        )
      },
      ">}}\n"
    )
  }
)

# knitr hook to use Hugo highlighting options
knitr::knit_hooks$set(
  source = function(x, options) {
  hlopts <- options$hlopts
    paste0(
      "```r ",
      if (!is.null(hlopts)) {
      paste0("{",
        glue::glue_collapse(
          glue::glue('{names(hlopts)}={hlopts}'),
          sep = ","
        ), "}"
        )
      },
      "\n", glue::glue_collapse(x, sep = "\n"), "\n```\n"
    )
  }
)
```


I really enjoy using [`targets`](https://doc.ropensci.org/targets) for all of my data analysis projects. They help me structure all of the projects nicely in the same folder. For them I often produce several figures using `ggplot2`. I want to keep my plots accessible to be able to revisit them anytime and to assemble them with `patchwork` into more complex figures for a potential paper. In a regular project I generate 10 to 20 figures, some only diagnostic ones and some final polished one for the potential finished manuscript. I do revisit the list of figures often, as co-authors or reviewers ask me for more detailed analyses and visualizations.

In most cases, I don't know before hand the sizes of the figures, so I like to save the ggplot2 plots as R objects and not images in my `targets` workflow. I sometimes edit them for a presentation, a paper, or a poster, so I like to the flexibility of saving them as R objects.

However, there are no formal recommendations to save ggplot2 objects in targets workflow. These can have different consequences for the size of stored cache, the loading time, the flexibility, and ease of use of the plots.

In this blog post I explore the different possible options and discuss their pros and cons, with some insights from both `ggplot2` and `targets` communities. I will show the consequences of using each one of them through a simple workflow making a plot with the `mtcars` dataset.


## First solution: saving the entire `ggplot2` objects without worrying

My first solution was to not worry about the plots and leverage the very clever system from targets that saves object.

Let's say our workflow loads the data and make a simple plot:

```{r first-workflow}
library("targets")
library("ggplot2")

# Create a simple demo workflow
tar_script({
  library("ggplot2")
  library("targets")
  
  list(
    tar_target(mtcars_df, mtcars),
    tar_target(
      simple_plot,
      ggplot(mtcars_df, aes(cyl, mpg)) +
        geom_point()
    )
  )
}, ask = FALSE)

# Run the workflow
tar_make()
```

Then if you want to access the plot you can use `tar_read()` or `tar_load()` and you'll get back a modifiable ggplot2 object

```{r first-load-plot}
tar_read(simple_plot)

# It's modifiable (we can add a theme after the fact)
tar_read(simple_plot) +
  theme_bw()
```

For now, the plot is pretty simple and low weight. We'll be using the `obj_size()` function from  `lobstr` package to evaluate the package size.

```{r first-size}
lobstr::obj_size(tar_read(simple_plot))
```

The problem arises when you start having plots with a lot going on in the plot function. If retake the same targets workflow but have a more busy plot function we'll be able to measure the size of the plot object again:

```{r first-busy-workflow}
tar_script({
  library("ggplot2")
  library("targets")
  
  list(
    tar_target(mtcars_df, mtcars),
    tar_target(
      simple_plot,
      ggplot(mtcars_df, aes(cyl, mpg)) +
        geom_point()
    ),
    tar_target(
      complex_plot,
      {
        
        # Add many useless manipulations here to mimick object creation
        mtcars_df2 = mtcars_df
        mtcars_df3 = rbind(mtcars_df, mtcars_df2)
        mtcars_df4 = rbind(mtcars_df3, mtcars_df3)
        
        # Note how the code of the plot hasn't changed
        ggplot(mtcars_df, aes(cyl, mpg)) +
          geom_point()
        
      }
    )
  )
}, ask = FALSE)

# Run the workflow
tar_make()
```

We now have two plot targets, the `simple_plot` target which is the same as previously and `complex_plot` which differs from `simple_plot` only from data manipulation prior to the plotting, **that are not affecting the plot object in itself**.

If we compare their sizes:

```{r first-complex-sizes}
# The 'simple_plot' object hasn't changed size
lobstr::obj_size(tar_read(simple_plot))

# The 'complex_plot' object is actually larger
lobstr::obj_size(tar_read(complex_plot))
```

We observe that the `complex_plot` is larger in size than `simple_plot`! This seems very surprising as we haven't changed a line of the plotting code *per se*. So what is happening here?
Well the issue comes from the way ggplot2 works: it doesn't save the graphical plots in themselves, it saves their **environment** and generates the plot only when called from this saved environment. If you're not familiar with the concept of environment, don't worry! It's a rather hard concept to grasp (and I'm not sure I do understand it, if you want to know more about it you can read the [dedicated chapter]() in [Advanced R](https://adv-r.hadley.nz/)). If we simplify the concept, the `ggplot()` function saves the plotting function in themselves **plus** all of the object lying around where it's called, because they may be useful for the plot (which one are useful ggplot2 can't tell because remember that the plot is only really rendered when called).

In our workflow example above, the size difference between both objects isn't much different, so it does not change the performance of the plot nor the total size taken by the saved targets workflow. However, with a real life example with many complex objects and many intermediate computations in the plotting function, it can increase loading and plotting times dramatically. So we need to think about solutions to circumvent the issue.


### Pros

* Works out of the box
* Have nothing to worry about
* Flexible with the size of the plots

### Cons

* Increased saved object size (and thus workflow size)
* If object is big, than slow to load


## Second (partial) solution: transform ggplot2 objects into `grObs` using target hooks

My workflows started to grow big and the plots were slow, so I asked around to the targets community for a solution. While it was considered at one point to propose [a specific storage for ggplot2 object], the reliance of the objects on environments made it impossible to solve. These objects need to be stored including all of their environment.

ggplot2 needs to render the plots when they are shown. This transformation relies on the framework of the `grid` package and the transformation of ggplot2 objects into `Grob` objects (short for **Gr**aphical **ob**jects). The plots then are purely graphical and contain no more the initial data nor the plotting environment. These objects are thus much lighter.

So a natural idea would be to save, within the targets workflow, the ggplot2 plots as `Grobs` to keep only the information to the plots themselves and not the initial data. This can be done using the `ggplot2::ggplotGrob()` function.

We can compare the size of the stored objects using our previous workflow and adding conversion to Grobs:

```{r second-workflow}
tar_script({
  library("ggplot2")
  library("targets")
  
  list(
    tar_target(mtcars_df, mtcars),
    tar_target(
      simple_plot,
      ggplot(mtcars_df, aes(cyl, mpg)) +
        geom_point()
    ),
    tar_target(
      complex_plot,
      {
        
        # Add many useless manipulations here to mimick object creation
        mtcars_df2 = mtcars_df
        mtcars_df3 = rbind(mtcars_df, mtcars_df2)
        mtcars_df4 = rbind(mtcars_df3, mtcars_df3)
        
        # Note how the code of the plot hasn't changed
        ggplot(mtcars_df, aes(cyl, mpg)) +
          geom_point()
        
      }
    ),
    tar_target(simple_grob, ggplotGrob(simple_plot)),
    tar_target(complex_grob, ggplotGrob(complex_plot))
  )
}, ask = FALSE)

# Run the workflow
tar_make()
```

We added 2 new targets `simple_grob` and `complex_grob` that transform the previous plots into Grobs.

If we compare their sizes now:

```{r second-grob-sizes}
lobstr::obj_size(tar_read(simple_grob))
lobstr::obj_size(tar_read(complex_grob))
```
Both objects are more than twice as small as the original plot object, and now they are both of the same size! So this may seem like a solution to us.

Let's check if we still can display them:

```{r second-grob-failed-plot}
tar_read(simple_grob)
```

This doesn't display a plot but shows us how the plot is stored as a `Grob` in the `grid` system. To display it we need to have a function that transform this object into an actual plot. For example, with the `grid::grid.draw()` function:

```{r second-grob-plot}
grid::grid.draw(tar_read(simple_grob))
```

We got our plot back! It is still resizable, can still be exported as a file through RStudio or graphical devices. However, as it's not a ggplot2 object anymore, we cannot tweak its theme nor use the `ggsave` function.

If you have tens of plots, it maybe quite cumbersome to call `ggplot2::ggplotGrob()` at the end of all your plot functions. That's where someone in the community suggested using [`tarchetypes` hooks](). I wasn't aware at the time, but tarchetypes, which is an extension of targets to more easily generate a list of targets, has a system of "hooks" that can apply functions to your targets automatically (all or a subset based on their names). These are accessible through the functions `tar_hook_before()`, `tar_hook_inner()`, and `tar_hook_outer()` in `tarchetypes`. They will respectively transform the target to execute a function *before*, wrap the target in, or (??? what's the difference between inner and outer?). We have to indicate with `.x` where is the previous commond supposed to be executed. This means that using `tar_hook_outer()` we would be able to automatically execute `ggplotGrob()` to all our plot targets like so:

```{r second-workflow-hooks}
tar_script({
  library("ggplot2")
  library("targets")
  
  list(
    tar_target(mtcars_df, mtcars),
    tar_target(
      simple_plot,
      ggplot(mtcars_df, aes(cyl, mpg)) +
        geom_point()
    ),
    tar_target(
      complex_plot,
      {
        
        # Add many useless manipulations here to mimick object creation
        mtcars_df2 = mtcars_df
        mtcars_df3 = rbind(mtcars_df, mtcars_df2)
        mtcars_df4 = rbind(mtcars_df3, mtcars_df3)
        
        # Note how the code of the plot hasn't changed
        ggplot(mtcars_df, aes(cyl, mpg)) +
          geom_point()
        
      }
    )
  ) |>
    # The hook from tarchetypes
    tarchetypes::tar_hook_outer(
      ggplot2::ggplotGrob(.x),
      names = ends_with("plot")
    )
}, ask = FALSE)

# Run the workflow
tar_make()
```

We can check our plot objects:

```{r second-hook-grob}
tar_read(simple_plot)
tar_read(complex_plot)
```

Both our plot objects indeed got transformed intro `Grob` objects! With the adapted sizes. With the hooks, we could easily transform all of the figures of a workflow into `Grobs`.

If this solution seems to solve all of our problems (though not as flexible), then why does this post continues?

Well, ggplot2 maintainers officially [discourage users to save `ggplotGrobs`](https://github.com/tidyverse/ggplot2/issues/4649#issuecomment-952029317). This is because they are not guaranteed to be reloadable. So this is quite a big concern for reusability of future objects.

We will explore other options in the next sections, but in this one we have learnt about what happens in ggplot2 to generate an actual plot through transforming into a grob, then we have learned about tarchetypes hooks.

### Pros

* Very lightweight total.
* Flexible in the final size of the image.
* Leverages the amazing (and not so known) hooks in a targets workflow.

### Cons

* Can't edit the ggplot2 object after the fact.
* Has to add a hook to the `targets` workflow.
* `grid` objects can be strange to work with.
* Officially not recommended by ggplot2 maintainers.


## Third solution: save the plots as images

A third solution would be to save all of the plots as images. This can be done through the use of the target hooks we learned about in the last section, or by invoking `ggsave()` as new targets.

We thus have to fix an image size and a file location in advance but at least the saved object would be clear: an actual image.

Here's how we could proceed with our previous workflow:

```{r third-workflow}
tar_script({
  library("ggplot2")
  library("targets")
  
  list(
    tar_target(mtcars_df, mtcars),
    tar_target(
      simple_plot,
      ggplot(mtcars_df, aes(cyl, mpg)) +
        geom_point()
    ),
    tar_target(
      complex_plot,
      {
        
        # Add many useless manipulations here to mimick object creation
        mtcars_df2 = mtcars_df
        mtcars_df3 = rbind(mtcars_df, mtcars_df2)
        mtcars_df4 = rbind(mtcars_df3, mtcars_df3)
        
        # Note how the code of the plot hasn't changed
        ggplot(mtcars_df, aes(cyl, mpg)) +
          geom_point()
        
      }
    ),
    tar_target(simple_grob, ggplotGrob(simple_plot)),
    tar_target(complex_grob, ggplotGrob(complex_plot))
  )
}, ask = FALSE)

# Run the workflow
tar_make()
```

### Pros

* Lightweight
* Easy file type

### Cons

* Fixed size a priori
* Can't edit easily the object after the fact



## Fourth (& final) solution: save `ggplot2` objects but thin the plotting environment

example of plot and change in size of object. (Where are we getting)

Need to care about whatever is floating around when creating

### Pros

* Works out of the box
* No need to fiddle with the workflow
* Lighter file size
* Flexible image size
* Can edit object after the fact

### Cons

* Have to edit carefully what's happening in the plotting functions


## Summary

We explored solutions to save ggplot2 objects in target workflows:

* Saving `ggplot2` objects directly without consideration may accidentally save bigger objects because it saves the plot environment
* `targets` hooks can help you post-process targets automatically
* Saving `ggplot2` as `Grob` is not recommended and shouldn't be done
* The solution is to save `ggplot2` and thinning any object that may be staying in the environment


## Conclusion


## Going Further

* R environments, Advanced R
* grid Grobs, ?
* ggplot2 plotting system, ggplot2 vignette or blog?
* targets serialization, targets book?
