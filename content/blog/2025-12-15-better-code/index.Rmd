---
title: Better Code, Without Any Effort, Without Even AI
author: 
- MaÃ«lle Salmon
editor:
- Etienne Bacher
date: '2025-12-15'
slug: better-code
description: Useful local, free, deterministic tools to improve your code
output: hugodown::md_document
tags:
  - best practice
  - tech notes
params:
  doi: "10.59350/98899-51c03"
---

We are experiencing a programming revolution, with the democratization of artificial intelligence... 
But also with the creation and improvement of more old-school tools to improve your code: local, free, deterministic. 
In this post, we will introduce you to Air, a tool for formatting R code automatically and almost instantly; 
lintr, an R package that detects more and more reasons to improve your code; 
jarl, a fast CLI tool to find and automatically fix lints;
flir, an R package to efficiently rewrite patterns of code, either built-in ones or custom ones.
With these four wonderful tools, you can effortlessly improve your code, your colleagues' code... and even code proposed by AI.
With a bit more effort, you might even internalize best practice and write better code from the get go in the future!

```{r, echo=FALSE}
lines <- c(
  "lleno <-!any(is.na(x))",
  "ok<- !(x[1] == y[1])",
  "if (ok) z<- x +  1",
  'if (z>3) stop("ouch")'
)
writeLines(lines, "test.R")
```

## An example script

Let's start with a script containing a few problems...
Can you spot them?

```{r, file="test.R", eval=FALSE, echo=TRUE}
```

### Learn what to improve with {lintr} :package:

A first instinct might be to run the lintr package on the script.
The `lint()` function performs static analysis.

```{r, echo=TRUE}
lintr::lint("test.R", linters = lintr::all_linters())
```

We therefore get alerts about

- styling: space around infix operators for instance; implicit integer.
- performance: `anyNA(x)` is better than `any(is.na(x))`.

Since lintr has been around for a long time, it has an impressive collection of rules, the "linters".
Even reading their documentation can teach you a lot, especially as the [list](https://lintr.r-lib.org/reference/index.html#individual-linters) grows over time!

Now, based on these alerts, how could we improve the code? 

### Format with Air :computer:$

In the terminal:

```sh
air format test.R
```

```{r, echo=FALSE}
a <- system2("air", c("format", "test.R"))
```

```{r, file="test.R", eval=FALSE, echo=TRUE}
```

Now, the spacing in the code is regular!
The `if` condition is furthermore formatted on three lines instead of only one.
Overall, the code is easier to read because it now follows popular conventions.

Note that lintr and Air might have conflicting advice on styling: you can deactivate lintr's styling related rules if you use Air.

### Improve with the new jarl CLI! :computer:$

In the terminal:

```sh
jarl check test.R --fix
```

```{r, echo=FALSE}
a <- system2("jarl", c("check", "test.R", "--fix", "--allow-dirty"))
```


```{r, file="test.R", eval=FALSE, echo=TRUE}
```

`any(is.na(x))` was automatically replaced with `anyNA(x)`!

The jarl CLI is as fast as Air is for styling.
Furthermore, because it is a simple binary that does not need R to run, it's quicker to install on continuous integration.

Nevertheless, since jarl is newer than lintr, it supports fewer rules for now.

### Improve with the {flir} :package:

You could complement the usage of lintr, Air and jarl with flir which is better at [*custom rules*](https://flir.etiennebacher.com/articles/adding_rules).
For instance, what if you'd prefer your codebase to use `rlang::abort()` instead of `stop()`?

We first run

```r
flir::setup_flir(getwd())
```

We save the file below under `flir/rules/custom/stop_abort.yml`.

```yaml
id: stop_abort-1
language: r
severity: warning
rule:
  pattern: stop($$$ELEMS)
fix: rlang::abort(paste0(~~ELEMS~~))
message: Use `rlang::abort()` instead of `stop()`.
```
We then run

```{r, echo=TRUE,eval=FALSE}
flir::fix("test.R", linters = "stop_abort")
```

```{r, file="test.R", eval=FALSE, echo=TRUE}
```

```{r}
#| echo: false
a <- file.remove("test.R")
```


## Tooling

The tools we used are:

- :computer:$ [Air](https://posit-dev.github.io/air/): CLI to format code, by Lionel Henry and Davis Vaughan.
- :package: [{flir}](https://flir.etiennebacher.com/): R package to fix code patterns, by Etienne Bacher.
- :computer:$ [jarl](https://jarl.etiennebacher.com/): CLI to fix code patterns, by Etienne Bacher.
- :package: [{lintr}](https://lintr.r-lib.org/): R package to get informed of even more code patterns, by [Michael Chirico and many others](https://lintr.r-lib.org/authors.html).


## How to use those tools

You could use those tools locally on your machine from time to time.
For instance, when inheriting an older project, I will first renovate it using them.
Locally, a real game changer is using the integration of your IDE with the tools.
For instance, I have Positron set up so that [Air](https://posit-dev.github.io/air/editors.html) is run on my scripts when I save them.
The jarl CLI also provides [integrations with editors](https://jarl.etiennebacher.com/editors).

You could also use those tools on continuous integration.
For instance, a workflow might [suggest formatting changes in Pull Requests](https://posit-dev.github.io/air/integration-github-actions.html#format-with-github-suggestions).
The use of suggestions rather than a direct commit means the contributor get a chance to learn about the improvements.

Whether to ask flir and jarl to do changes as opposed to _alerting_ you about them depends on the context.
You might learn more by doing the changes yourself.
In any case, having a proper look at modifications before committing them is crucial!

## What about artificial intelligence?

Sure, artificial intelligence can be handy but...

- The best LLMs are not local;

- They cost money;

- They are not deterministic so might miss a rule whereas the tools in this post don't;

- Their usage entail some ideological and ethical problems that we won't list here.

Furthermore, for such alerts and fixes, you don't need to use an LLM... 
Air, flir, jarl, lintr already do an excellent job!

## Conclusion

You can improve your code without effort, without even AI, using:

- Air, to efficiently reformat code;

- {flir}, to efficiently refactor code;

- jarl, to fix "bad" practice;

- {lintr} to get "bad" patterns, including custom ones, flagged.

The usage of those tools is best complemented by review by humans.
