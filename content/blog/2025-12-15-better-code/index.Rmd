---
title: Better Code, Without Any Effort, Without Even AI
author: 
- MaÃ«lle Salmon
editor:
- Etienne Bacher
- Steffi LaZerte
date: '2025-12-15'
slug: better-code
description: Useful local, free, deterministic tools to improve your code
output: hugodown::md_document
tags:
  - best practice
  - tech notes
  - package development
params:
  doi: "10.59350/98899-51c03"
---

We are experiencing a programming revolution, with the democratization of artificial intelligence,
*but* also with the creation and improvement of more traditional software tools to improve your code: local, free, deterministic. 

In this post, we will introduce you to 

- [lintr](https://lintr.r-lib.org/), an R package that detects many ways to improve your code; 
- [Air](https://posit-dev.github.io/air/), a fast CLI (command-line interface) for formatting R code automatically and almost instantly; 
- [jarl](https://jarl.etiennebacher.com/), another fast CLI (command-line interface) tool to find and automatically fix lints;
- [flir](https://flir.etiennebacher.com/), an R package to efficiently rewrite patterns of code, either built-in ones or custom ones.

With these four wonderful tools, you can effortlessly improve your code, your colleagues' code... and even code proposed by AI.
With a bit more effort, you might even internalize best practice and write better code from the get go in the future!

```{r, echo=FALSE}
lines <- c(
  "lleno <-!any(is.na(x))",
  "ok<- !(x[1] == y[1])",
  "if (ok) z<- x +  1",
  'if (z>3) stop("ouch")'
)
writeLines(lines, "test.R")
```

## An example script

Let's start with a script containing a few problems...
Can you spot them?

```{r, file="test.R", eval=FALSE, echo=TRUE}
```

### The R console vs the terminal

Note that in this post, some tools are used in the R console, but others are used in the terminal, that you might also know as command line or [shell](https://12days.cmdchallenge.com/#/12days_2).

### Learn what to improve with {lintr} :package:

A first instinct might be to run the lintr package on the script.
The `lint()` function performs static analysis and highlights potential problems in your R code, including formatting and programming suggestions.

```{r, echo=TRUE,eval=FALSE}
lintr::lint("test.R", linters = lintr::all_linters())
```
```{r, echo=FALSE,eval=TRUE}
lintr::lint_dir(pattern = "(?i)[.]r", linters = lintr::all_linters())
```

We therefore get alerts about

- styling: space around infix operators for instance; implicit integer.
- performance: `anyNA(x)` is better than `any(is.na(x))`.

Since lintr has been around for a long time, it has an impressive collection of rules, the "linters".
Even reading their documentation can teach you a lot, especially as the [list](https://lintr.r-lib.org/reference/index.html#individual-linters) grows over time!

Now, based on these alerts, how could we improve the code? 

### Format with Air :computer:$
Air is software which automatically formats your R code according to a set of rules.

In the terminal:

```sh
air format test.R
```
 And this returns:
```{r, echo=FALSE}
a <- system2("air", c("format", "test.R"))
```

```{r, file="test.R", eval=FALSE, echo=TRUE}
```

Now, the spacing in the code is regular!
The `if` condition is furthermore formatted on three lines instead of only one.
Overall, the code is easier to read because it now follows popular conventions.

Note that lintr and Air might have conflicting advice on styling: you can [deactivate lintr's styling](https://lintr.r-lib.org/articles/lintr.html#the--lintr-file) related rules if you use Air.

### Improve with the new jarl CLI! :computer:$
Similar to Air, jarl formats your code, and like lintr, identifies potential problems, but unlike lintr, jarl also applies fixes!

In the terminal:

```sh
jarl check test.R --fix
```

```{r, echo=FALSE}
a <- system2("jarl", c("check", "test.R", "--fix", "--allow-dirty"))
```


```{r, file="test.R", eval=FALSE, echo=TRUE}
```

`any(is.na(x))` was automatically replaced with `anyNA(x)`!

The jarl CLI is as fast for checking and fixing lints as Air is for styling.
Furthermore, because it is a simple binary that does not need R to run, it's quicker to install on continuous integration.

However, since jarl is newer than lintr, it supports fewer rules for now.

### Improve with the {flir} :package:

You could complement the usage of lintr, Air and jarl with flir which is better at [*custom rules*](https://flir.etiennebacher.com/articles/adding_rules).
For instance, what if you'd prefer your codebase to use `rlang::abort()` instead of `stop()`?

We first run

```r
flir::setup_flir(getwd())
```

We save the file below under `flir/rules/custom/stop_abort.yml`.

```yaml
id: stop_abort-1
language: r
severity: warning
rule:
  pattern: stop($$$ELEMS)
fix: rlang::abort(paste0(~~ELEMS~~))
message: Use `rlang::abort()` instead of `stop()`.
```
We then run

```{r, echo=TRUE,eval=TRUE}
flir::fix("test.R", linters = "flir/rules/custom/stop_abort.yml")
```

```{r, file="test.R", eval=FALSE, echo=TRUE}
```

The call to `stop()` was automatically replaced.
Now, we might want to then manually remove the useless `paste0()`, but we're already closer to an ideal script.

```{r}
#| echo: false
a <- file.remove("test.R")
```


## Tooling

The tools we used are:

- :package: [{lintr}](https://lintr.r-lib.org/): R package to get informed of many code patterns, by [Michael Chirico and many others](https://lintr.r-lib.org/authors.html).
- :computer:$ [Air](https://posit-dev.github.io/air/): CLI to format code, by Lionel Henry and Davis Vaughan.
- :computer:$ [jarl](https://jarl.etiennebacher.com/): CLI to fix code patterns, by Etienne Bacher.
- :package: [{flir}](https://flir.etiennebacher.com/): R package to fix custom code patterns, by Etienne Bacher.


## Integrating these tools into your workflow

Locally, you can use those tools as needed.
For instance, when inheriting an older project, the first thing I do is renovate the project by applying these tools.
A real game changer is using the integration of these tools with your IDE.
For instance, I have Positron set up so that [Air](https://posit-dev.github.io/air/editors.html) runs on my scripts when I save them.
The jarl CLI also provides [integrations with IDEs](https://jarl.etiennebacher.com/editors).

You can also use those tools on continuous integration.
For instance, a useful workflow might be to [suggest formatting changes on Pull Requests](https://posit-dev.github.io/air/integration-github-actions.html#format-with-github-suggestions).
The use of suggestions rather than a direct commit means the contributor get a chance to learn about the improvements.

Another aspect to consider is whether you want flir and jarl to _make_ the changes as opposed to _alerting_ you about them. 
Which you choose depends on the context, for example, you might learn more by doing the changes yourself.
In any case, having a proper look at modifications before committing them is important!

## What about artificial intelligence?

Artificial intelligence can be useful in coding applications but...

- The best LLMs are not local;

- They cost money and are slower;

- They are not deterministic so might miss a rule whereas the tools in this post don't;

- Their usage entail some ideological and ethical problems that we won't list here.

Furthermore, for such alerts and fixes, you don't need to use an LLM... 
Air, flir, jarl, and lintr already do an excellent job!

## Conclusion

You can improve your code without effort, without even AI, using:

- {lintr} to signal "bad" patterns, including [customizable ones](https://github.com/r-lib/pkgdown/blob/c07d935583c90125586821e3b39ed52f16593e42/.lintr.R#L1);

- Air, to efficiently reformat code;

- jarl, to detect and fix "bad" patterns;

- {flir}, to efficiently refactor code with custom rules.

The usage of those tools is best complemented by review by humans.
